package hcmut.clustering.engine;

import hcmut.clustering.model.Cluster;
import hcmut.clustering.model.Clusters;
import hcmut.clustering.model.Point;
import hcmut.clustering.model.Points;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;

public class OPTICS {

    /**
     * Properties declaration
     */
    private Points points;
    private double eps;
    private int minPts;
    private ArrayList<Point> orderedList;

    /**
     * Default Constructor
     */
    public OPTICS() {
        orderedList = new ArrayList<Point>();
    }

    /**
     * Constructor
     * @param points
     * @param eps
     * @param minPts
     */
    public OPTICS(Points points, double eps, int minPts) {
        this();
        this.points = points;
        this.eps = eps;
        this.minPts = minPts;
    }

    /**
     * Set arguments of OPTICS engine
     * @param points
     * @param eps
     * @param minPts
     */
    public void setArguments(Points points, double eps, int minPts) {
        this.points = points;
        this.eps = eps;
        this.minPts = minPts;
    }

    /**
     * Get ordered list generated by OPTICS algorithm
     * @return orderedList
     */
    public ArrayList<Point> getOrderedList() {
        return orderedList;
    }

    /**
     * Extract cluster from
     * @param eps
     * @return
     */
    public Clusters getClusters(double eps) {
        Clusters clusters = new Clusters();

        Points tmp = new Points();

        for (Point point: orderedList) {
            if (point.getReachDist() <= eps) {
                tmp.add(point);
            }
            else if (tmp.size() >= minPts) {
                clusters.addCluster(new Cluster(tmp));
                tmp.clear();
            }
            else {
                tmp.clear();
            }
        }

        if (tmp.size() != 0)
            clusters.addCluster(new Cluster(tmp));

        return clusters;
    }

    /**
     * Construct clusters methods
     */
    public void constructClusters(){
        for (int i = 0; i < points.size(); i++) {
            Point point = points.getPoint(i);

            if (!point.isVisited()) {
                point.setVisited(true);

                Points neighbors = point.regionQuery(eps, points);

                orderedList.add(point);

                PriorityQueue<Point> seeds = new PriorityQueue<Point>(points.size(), new Comparator<Point>() {
                    @Override
                    public int compare(Point o1, Point o2) {
                        if (o1.getReachDist() < o2.getReachDist()) {
                            return -1;
                        }
                        else if (o1.getReachDist() > o2.getReachDist()) {
                            return 1;
                        }
                        return 0;
                    }
                });

                if (neighbors.size() >= minPts) {
                    update(point, neighbors, seeds);
                    while (!seeds.isEmpty()) {
                        Point tmp = seeds.poll();
                        Points tmpNeighbors = tmp.regionQuery(eps, points);
                        tmp.setVisited(true);
                        orderedList.add(tmp);
                        if (tmpNeighbors.size() >= minPts) {
                            update(tmp, tmpNeighbors, seeds);
                        }
                    }
                }
            }
        }
    }

    /**
     * Update method
     * @param core
     * @param neighbors
     * @param seeds
     */
    private void update(Point core, Points neighbors, PriorityQueue<Point> seeds) {
        double coreDist = coreDistance(core, neighbors);
        if (core.getReachDist() == 0)
            core.setReachDist(coreDist);

        for (Point point: neighbors) {
            if (!point.isVisited()) {
                double newReachDist = Math.max(coreDist, core.distance(point));
                if (point.getReachDist() == 0) {
                    point.setReachDist(newReachDist);
                    seeds.add(point);
                }
                else if (point.getReachDist() > newReachDist) {
                    seeds.remove(point);
                    point.setReachDist(newReachDist);
                    seeds.add(point);
                }
            }
        }
    }

    /**
     * Calculating core distance method
     * @param core
     * @param neighbors
     * @return
     */
    private double coreDistance(Point core, Points neighbors) {
        double coreDistance = 0;

        for (Point point: neighbors) {
            if (point != core) {
                double tmp = point.distance(core);
                if (core.regionQuery(tmp, points).size() >= minPts) {
                    coreDistance = tmp;
                    break;
                }
            }
        }

        for (Point point: neighbors) {
            if (point != core) {
                double tmp = point.distance(core);
                if(core.regionQuery(tmp, points).size() >= minPts && tmp < coreDistance) {
                    coreDistance = tmp;
                }
            }
        }

        return coreDistance;
    }
}
